from .data_handler import DataHandler
from .greeks_engine import GreeksEngine
from .portfolio import Portfolio
from .position_sizer import PositionSizer
from .execution_handler import ExecutionHandler
from .strategy import BaseStrategy, DeltaHedgingMixin, DeltaGammaHedgingMixin, LSTMStrategy, RLStrategy, JumpDiffusionStrategy
from .entities import Order, Fill, Position, Option, Stock

__all__ = [
    "DataHandler",
    "GreeksEngine",
    "Portfolio",
    "PositionSizer",
    "ExecutionHandler",
    "BaseStrategy",
    "DeltaHedgingMixin",
    "DeltaGammaHedgingMixin",
    "LSTMStrategy",
    "RLStrategy",
    "JumpDiffusionStrategy",
    "Order",
    "Fill",
    "Position",
    "Option",
    "Stock",
] from __future__ import annotations

import datetime as dt
import re
from typing import List, Optional

import pandas as pd
from alpaca.data.historical import StockHistoricalDataClient
from alpaca.data.requests   import StockBarsRequest
from alpaca.data.timeframe  import TimeFrame, TimeFrameUnit
from polygon import RESTClient

# ──────────────────────  utility: convert "5Min" → TimeFrame  ────────────────
_TIMEFRAME_RE = re.compile(r"(\d+)([A-Za-z]+)")

def _parse_timeframe(freq: str) -> TimeFrame:
    m = _TIMEFRAME_RE.fullmatch(freq)
    if not m:
        raise ValueError(
            f"Bad timeframe '{freq}'. Use formats like '5Min', '12H', '1D'."
        )
    n, unit = int(m.group(1)), m.group(2).lower()

    if unit in ("min", "t"):
        return TimeFrame(n, TimeFrameUnit.Minute) # type: ignore[attr-defined]
    if unit in ("hour", "h"):
        return TimeFrame(n, TimeFrameUnit.Hour) # type: ignore[attr-defined]
    if unit in ("day", "d"):
        return TimeFrame(n, TimeFrameUnit.Day) # type: ignore[attr-defined]
    if unit in ("week", "w"):
        return TimeFrame(n, TimeFrameUnit.Week) # type: ignore[attr-defined]
    if unit in ("month", "m"):
        return TimeFrame(n, TimeFrameUnit.Month) # type: ignore[attr-defined]

    raise ValueError(f"Unsupported timeframe unit '{unit}' in '{freq}'")

class DataHandler:
    """
    Unified wrapper around:

    • Alpaca historical stock bars (OHLCV)
    • Polygon reference endpoints (contract discovery)
    • Polygon aggregates for options (minute/hour/day bars)

    Only the three methods required for your Δ-hedge, ΔΓ-hedge and jump-premium
    back-tests are implemented.  Anything extra (quotes, snapshots, Greeks)
    can be added as tiny helpers later.
    """

    def __init__(
        self,
        alpaca_api_key: str,
        alpaca_secret: str,
        polygon_key: str,
        tz: dt.tzinfo = dt.timezone.utc,
    ):
        self._alpaca = StockHistoricalDataClient(alpaca_api_key, alpaca_secret)
        self._poly   = RESTClient(polygon_key)
        self._tz     = tz

    def get_stock_bars(
        self,
        ticker: str,
        start_date: str,
        end_date: str,
        timeframe: str = "1Min",
    ) -> pd.DataFrame:
        """
        Pull OHLCV bars for one equity symbol via Alpaca and return a tidy
        `pandas.DataFrame` indexed by (tz-aware) timestamp.
        """
        tf = _parse_timeframe(timeframe)

        req = StockBarsRequest(
            symbol_or_symbols=ticker,
            timeframe=tf,
            start=dt.datetime.fromisoformat(start_date).replace(tzinfo=self._tz),
            end=dt.datetime.fromisoformat(end_date).replace(tzinfo=self._tz),
        )

        bars = self._alpaca.get_stock_bars(req).df.sort_index() # type: ignore[attr-defined]

        if isinstance(bars.index, pd.MultiIndex):          # flatten 1-symbol query
            bars = bars.xs(ticker, level="symbol")

        return bars.tz_convert(self._tz)

    def options_search(
        self,
        underlying: str,
        exp_from: str | None = None,
        exp_to:   str | None = None,
        strike_min: float | None = None,
        strike_max: float | None = None,
        opt_type:   str | None = None,     # 'call' | 'put'
        as_of:      str | None = None,
        limit: int = 10_000,
    ) -> list[str]:
        """
        Return contract tickers (no 'O:' prefix) using Polygon's
        `list_options_contracts` generator.  Works with historical chains
        via `as_of='YYYY-MM-DD'`.
        """
        contracts_iter = self._poly.list_options_contracts(
            underlying_ticker   = underlying,
            contract_type       = opt_type,
            expiration_date_gte = exp_from,
            expiration_date_lte = exp_to,
            as_of               = as_of,
            limit               = limit,
        )

        tickers = []
        for c in contracts_iter:
            if isinstance(c, bytes):
                # If bytes, decode to string and append
                tickers.append(c.decode())
            else:
                k = c.strike_price  # float
                if strike_min is not None and k is not None and k < strike_min:
                    continue
                if strike_max is not None and k is not None and k > strike_max:
                    continue
                tickers.append(c.ticker)  # e.g. 'AAPL240322C00185000'
        return tickers

    def get_option_aggregates(
        self,
        option_ticker: str,              # WITHOUT 'O:'
        start_date: str,
        end_date: str,
        timespan: str = "minute",        # 'minute', 'hour', 'day'
        multiplier: int = 1,
        adjust: bool = True,
    ) -> pd.DataFrame:
        """
        Historical OHLCV bars for a single option contract.
        Polygon's newer SDK returns a *list*; older SDK returns an Aggs obj.
        This helper accommodates both.
        """
        resp = self._poly.get_aggs(
            ticker     = f"{option_ticker}",   # NOTE the 'O:' prefix
            multiplier = multiplier,
            timespan   = timespan,
            from_      = start_date,
            to         = end_date,
            adjusted   = adjust,
            sort       = "asc",
            limit      = 50_000,
        )

        # ── normalise to a list of Agg objects ────────────────────────────
        data = resp  # No need for hasattr(resp, "results")
        if not data:
            raise ValueError(f"No aggregate data for {option_ticker}")

        # ── build tidy DataFrame ───────────────────────────────────────────
        df = pd.DataFrame([a.__dict__ for a in data]).set_index("timestamp")
        df.index = pd.to_datetime(df.index, unit="ms", utc=True).tz_convert(self._tz)

        return (
            df.rename(
                columns={
                    "open": "open",
                    "high": "high",
                    "low":  "low",
                    "close": "close",
                    "volume": "volume",
                    "vwap":   "vwap",
                    "transactions": "trades",
                }
            )
            .sort_index()
            .astype(
                {
                    "open": float,
                    "high": float,
                    "low": float,
                    "close": float,
                    "volume": int,
                    "vwap": float,
                    "trades": int,
                }
            )
        ) class Order:
    def __init__(self, symbol, qty, side, type, limit=None, time_in_force=None, **kwargs):
        self.symbol = symbol
        self.qty = qty
        self.side = side  # 'buy' or 'sell'
        self.type = type  # 'market' or 'limit'
        self.limit = limit
        self.time_in_force = time_in_force
        # Any other fields (e.g., order_id, etc.) can be added via kwargs
        for k, v in kwargs.items():
            setattr(self, k, v)

class Fill:
    def __init__(self, symbol, qty, price, timestamp, order_id=None):
        self.symbol = symbol
        self.qty = qty
        self.price = price
        self.timestamp = timestamp
        self.order_id = order_id

class Position:
    def __init__(self, symbol, qty, avg_cost, **kwargs):
        self.symbol = symbol
        self.qty = qty
        self.avg_cost = avg_cost
        # Any other useful fields
        for k, v in kwargs.items():
            setattr(self, k, v)

class Option:
    def __init__(self, symbol, expiration_date, strike_price, type="call", qty=0, **kwargs):
        self.symbol = symbol
        self.expiration_date = expiration_date
        self.strike_price = strike_price
        self.type = type  # 'call' or 'put'
        for k, v in kwargs.items():
            setattr(self, k, v)

class Stock:
    def __init__(self, symbol, qty=0, **kwargs):
        self.symbol = symbol
        self.qty = qty
        for k, v in kwargs.items():
            setattr(self, k, v) class ExecutionHandler:
    def get_fills(self, order):
        pass class GreeksEngine:
    def __init__(self, stock_bars=None, option_bars=None, pricing_model="Black-Scholes"):
        pass

    def compute(self, **kwargs):
        pass

    def align_option_data(self):
        pass

    def plot_iv(self):
        pass

    # Any other helpful helpers
    def helper(self):
        pass class Portfolio:
    def __init__(self):
        pass

    def update_with_fill(self, fill):
        pass

    def portfolio_view(self):
        pass class PositionSizer:
    def get_orders(self, target):
        pass class BaseStrategy:
    def generate_raw_target(self, ts, i):
        pass

    def on_bar(self, big_df, i, portfolio_view):
        pass

# Placeholder for mixins
class DeltaHedgingMixin:
    def apply(self, raw_target, greeks, portfolio):
        pass

class DeltaGammaHedgingMixin:
    def apply(self, raw_target, greeks, portfolio):
        pass

# Placeholder for strategy implementations
class LSTMStrategy(BaseStrategy):
    pass

class RLStrategy(BaseStrategy):
    pass

class JumpDiffusionStrategy(BaseStrategy):
    pass 